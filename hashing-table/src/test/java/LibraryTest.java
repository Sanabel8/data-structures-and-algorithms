/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

import static org.junit.Assert.*;

public class LibraryTest {
  @Test
  public void testHash() {
    HashTable<String, Integer> books = new HashTable<>();
    books.add("The Great Gatsby", 2);
    books.add("Passage to India", 5);
    books.add("Beloved", 7);
    books.add("To Kill a Mockingbird", 9);

    assertEquals(4, books.getSize());

  }

  @Test
  public void testHash2() {
    HashTable<String, Integer> books = new HashTable<>();
    books.add("The Great Gatsby", 2);
    books.add("Passage to India", 5);
    books.add("Beloved", 7);
    books.add("To Kill a Mockingbird", 9);

    assertFalse(books.isEmpty());
  }

  @Test
  public void testHash3() {
    HashTable<String, Integer> books = new HashTable<>();
    assertTrue(books.isEmpty());
  }

  @Test
  public void testHash4() {
    HashTable<String, Integer> books = new HashTable<>();
    books.add("The Great Gatsby", 2);
    books.add("Passage to India", 5);
    books.add("Beloved", 7);
    books.add("To Kill a Mockingbird", 9);

    assertTrue(books.contains("Beloved"));

  }

  @Test
  public void testHash5() {
    HashTable<String, Integer> books = new HashTable<>();
    books.add("The Great Gatsby", 2);
    books.add("Passage to India", 5);
    books.add("Beloved", 7);
    books.add("To Kill a Mockingbird", 9);

    assertFalse(books.contains("sanabel"));

  }

  ////////cc32/////////

  @Test
  public void binaryTreeTest1() {

    HashTable<Integer, Integer> bt = new HashTable<Integer, Integer>();
    BinaryTrees bt1 = new BinaryTrees();
    BinaryTrees bt2 = new BinaryTrees();

    bt1.setRoot(new Node(2));
    bt1.getRoot().setLeft(new Node(10));
    bt1.getRoot().setRight(new Node(11));
    bt1.getRoot().getRight().setLeft(new Node(4));
    bt1.getRoot().getRight().setRight(new Node(6));

    bt2.setRoot(new Node(6));
    bt2.getRoot().setLeft(new Node(10));
    bt2.getRoot().setRight(new Node(4));
    bt2.getRoot().getRight().setLeft(new Node(2));
    bt2.getRoot().getRight().setRight(new Node(33));

    assertEquals("[6, 10, 4, 2]", bt.insertionMethod(bt1, bt2).toString());

  }

  @Test
  public void noCommenValue() {

    HashTable<Integer, Integer> bt = new HashTable<Integer, Integer>();
    BinaryTrees bt1 = new BinaryTrees();
    BinaryTrees bt2 = new BinaryTrees();

    bt1.setRoot(new Node(11));
    bt1.getRoot().setLeft(new Node(111));
    bt1.getRoot().setRight(new Node(1111));
    bt1.getRoot().getRight().setLeft(new Node(11111));
    bt1.getRoot().getRight().setRight(new Node(0));

    bt2.setRoot(new Node(22));
    bt2.getRoot().setLeft(new Node(222));
    bt2.getRoot().setRight(new Node(2222));
    bt2.getRoot().getRight().setLeft(new Node(22222));
    bt2.getRoot().getRight().setRight(new Node(222222));

    assertEquals("[]", bt.insertionMethod(bt1, bt2).toString());

  }
//////////////////////////cc33////////////////////////////////
  @Test
  public void hashLeftJoinTest() {
    HashMap hashMap1 = new HashMap<>();
    HashMap hashMap2 = new HashMap<>();

    hashMap1.put("fond", "enamored");
    hashMap1.put("wrath", "anger");
    hashMap1.put("diligent", "employed");
    hashMap1.put("outfit", "garb");
    hashMap1.put("guide", "usher");

    hashMap2.put("fond", "averse");
    hashMap2.put("wrath", "delight");
    hashMap2.put("diligent", "idle");
    hashMap2.put("guide", "follow");
    hashMap2.put("flow", "jam");

    assertEquals("[diligent: [ employed, idle ], outfit: [ garb, null ], wrath: [ anger, delight ], guide: [ usher, follow ], fond: [ enamored, averse ]]", HashTable.leftJoin(hashMap1, hashMap2).toString());
  }
  @Test
  public void hashLeftJoinTest2() {
    HashMap hashMap1 = new HashMap<>();
    HashMap hashMap2 = new HashMap<>();


    assertEquals("[]", HashTable.leftJoin(hashMap1, hashMap2).toString());
  }
  @Test
  public void hashLeftJoinTest3(){
    HashMap hashMap1 = new HashMap();
    HashMap hashMap2 = new HashMap();
    hashMap1.put("fond", "enamored");
    hashMap1.put("wrath", "anger");
    hashMap1.put("diligent", "employed");
    hashMap1.put("outfit", "garb");
    hashMap1.put("guide", "usher");

    assertEquals("[diligent: [ employed, null ], outfit: [ garb, null ], wrath: [ anger, null ], guide: [ usher, null ], fond: [ enamored, null ]]", HashTable.leftJoin(hashMap1, hashMap2).toString());

  }
  @Test
  public void hashLeftJoinTest4(){
    HashMap hashMap1 = new HashMap();
    HashMap hashMap2 = new HashMap();

    hashMap2.put("fond", "averse");
    hashMap2.put("wrath", "delight");
    hashMap2.put("diligent", "idle");
    hashMap2.put("guide", "follow");
    hashMap2.put("flow", "jam");

    assertEquals("[]", HashTable.leftJoin(hashMap1, hashMap2).toString());

  }
  @Test
  public void hashLeftJoinTest5(){
    HashMap hashMap1 = new HashMap();
    HashMap hashMap2 = new HashMap();

    hashMap1.put("fond", "enamored");
    hashMap1.put("wrath", "anger");
    hashMap1.put("diligent", "employed");
    hashMap1.put("outfit", "garb");
    hashMap1.put("guide", "usher");

    hashMap2.put("fond", "averse");
    hashMap2.put("wrath", "delight");


    assertEquals("[diligent: [ employed, null ], outfit: [ garb, null ], wrath: [ anger, delight ], guide: [ usher, null ], fond: [ enamored, averse ]]", HashTable.leftJoin(hashMap1, hashMap2).toString());

  }
}

