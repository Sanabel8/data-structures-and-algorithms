# Singly Linked List
<!-- Short summary or background information -->
Linked List :1. sequence of Nodes each Node references the next Node in the link.
             2. A data structure that contains nodes that links/points to the next node in the list.
## Challenge
<!-- Description of the challenge -->
Adds a new node with that value to the head of the list with an O(1) Time performance.


## Approach & Efficiency
<!-- What approach did you take? Why? What is the Big O space/time for this approach? -->
Verify Big O(1) of written code.
Verify code matches algorithm.

## API
Methods in LinkedList Class
insert(Node newNode): This method accepts a Node parameter and its purpose to add a new Node in the LinkedList.

isInclude(Node head, int value): This method accepts a Node parameter and int parameter and its purpose to test our Nodes' values if they are found so the test gives us true or return false. 

# Challenge Summary
<!-- Description of the challenge -->
append(int value) : make method to added anew node to the end of the list
insertBefore(int data, int newData): make method to adds a new node with the given new value immediately before the first node that has the value specified
insertAfter(int data, int newValue): make method adds a new node with the given new value immediately after the first node that has the value specified
## Whiteboard Process
<!-- Embedded whiteboard image -->

[white-bora1](whitebord1.jpg)
[white-borad2](whitebord2.jpg)
[white-borad3](whiteboard3.jpg)
isInclude(Node head, int value): This method accepts a Node parameter and int parameter and its purpose to test our Nodes' values if they are found so the test gives us true or return false.             




# Challenge Summary
<!-- Description of the challenge -->
write method Return the nodeâ€™s value that is k places from the tail of the linked list.
## Whiteboard Process
<!-- Embedded whiteboard image -->
[linked-list-kth](code-challenge5/linked-list-kth.jpg)
## Approach & Efficiency
<!-- What approach did you take? Why? What is the Big O space/time for this approach? -->
Gig o/complexity
  space: o(n)
  time : o(n)
## Solution
<!-- Show how to run your code, and examples of it in action -->
input head -> [1] -> [3] -> [8] -> [2] -> X
output 2
Arg k  3




# Challenge Summary
<!-- Description of the challenge -->
appended method : make method to added anew node to the end of the list
insertBefore method : make method to adds a new node with the given new value immediately before the first node that has the value specified
insert after method: make method adds a new node with the given new value immediately after the first node that has the value specified
## Whiteboard Process
<!-- Embedded whiteboard image -->
[append](append.jpg)
[insert-before](insertBefor.jpg)
[insertAfter](insertAfter.jpg)

## Approach & Efficiency
<!-- What approach did you take? Why? What is the Big O space/time for this approach? -->
Gig o/complexity for all method 
  space: o(n)
  time : o(n)


# Challenge Summary
<!-- Description of the challenge -->
Code Challenge: Class 08
write method to Zip two linked lists ,and return a reference to the head of the zipped list.
## Whiteboard Process
<!-- Embedded whiteboard image -->
[linked-list-zip](code-challenge5/linked-list-zip.jpg)
## Approach & Efficiency
<!-- What approach did you take? Why? What is the Big O space/time for this approach? -->
Gig o/complexity
  space: O(n)
  time : o(n)












